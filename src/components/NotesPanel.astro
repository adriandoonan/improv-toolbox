---
interface Props {
  contentId: string;
  contentType: string;
  contentTitle: string;
}
const { contentId, contentType, contentTitle } = Astro.props as Props;
const noteKey = `${contentType}:${contentId}`;
---

<section
  class="notes-panel"
  data-note-root
  data-note-key={noteKey}
  data-note-title={contentTitle}
  data-note-type={contentType}
>
  <h2>Your notes</h2>
  <p class="note-helper">
    Notes live on your device first. We'll keep them ready for optional sync later.
  </p>
  <label class="note-field">
    <span class="note-field__label">Markdown-friendly note</span>
    <textarea
      rows="8"
      placeholder="Capture how you adapt this content to your troupe..."
      aria-describedby={`note-status-${noteKey}`}
    ></textarea>
  </label>
  <p class="note-meta" data-note-meta></p>
  <div class="note-toolbar">
    <button type="button" class="primary" data-note-save>
      Save note
    </button>
    <button type="button" class="secondary" data-note-export>
      Export all notes
    </button>
    <span
      id={`note-status-${noteKey}`}
      role="status"
      class="note-status"
      aria-live="polite"
    ></span>
  </div>
  <details class="note-preview">
    <summary>Preview</summary>
    <div data-note-preview></div>
  </details>
</section>

<style>
  .notes-panel {
    margin-top: 3rem;
    border-top: 1px solid var(--pico-muted-border-color, hsla(0, 0%, 100%, 0.1));
    padding-top: 2rem;
    display: grid;
    gap: 1rem;
  }

  .note-helper {
    margin: 0;
    color: var(--pico-muted-color);
    font-size: 0.95rem;
  }

  .note-field {
    display: grid;
    gap: 0.5rem;
  }

  .note-field textarea {
    width: 100%;
    resize: vertical;
  }

  .note-field textarea.note-field--readonly {
    cursor: not-allowed;
    opacity: 0.6;
  }

  .note-meta {
    margin: 0;
    font-size: 0.9rem;
    color: var(--pico-muted-color);
  }

  .note-toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    align-items: center;
  }

  .note-status {
    min-height: 1.5rem;
    font-size: 0.9rem;
    color: var(--pico-muted-color);
  }

  .note-preview summary {
    cursor: pointer;
  }

  .note-preview div {
    padding: 0.5rem 0;
    white-space: pre-wrap;
    font-family: var(--pico-font-family-monospace, ui-monospace, SFMono-Regular, SFMono, "Roboto Mono", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace);
  }
</style>

<script type="module" lang="ts">
  const STORAGE_NAMESPACE = "improv-toolbox:notes";
  const STORAGE_VERSION = 1;
  const storageSupported = (() => {
    if (typeof window === "undefined" || !("localStorage" in window)) {
      return false;
    }
    try {
      const probeKey = "improv-toolbox:notes-probe";
      localStorage.setItem(probeKey, "ok");
      localStorage.removeItem(probeKey);
      return true;
    } catch (error) {
      console.warn("Local storage is not available for notes", error);
      return false;
    }
  })();

  const panels = Array.from(document.querySelectorAll("[data-note-root]"));

  panels.forEach((panel) => {
    const textarea = /** @type {HTMLTextAreaElement | null} */ (
      panel.querySelector("textarea")
    );
    const preview = /** @type {HTMLDivElement | null} */ (
      panel.querySelector("[data-note-preview]")
    );
    const status = /** @type {HTMLSpanElement | null} */ (
      panel.querySelector(".note-status")
    );
    const saveButton = /** @type {HTMLButtonElement | null} */ (
      panel.querySelector("[data-note-save]")
    );
    const exportButton = /** @type {HTMLButtonElement | null} */ (
      panel.querySelector("[data-note-export]")
    );
    const meta = /** @type {HTMLParagraphElement | null} */ (
      panel.querySelector("[data-note-meta]")
    );
    if (!textarea || !preview || !status || !exportButton || !saveButton || !meta) {
      return;
    }

    const noteKey = panel.dataset.noteKey ?? "";
    const noteTitle = panel.dataset.noteTitle ?? "";
    const noteType = panel.dataset.noteType ?? "content";

    let storageReady = storageSupported;
    /** @type {NotesPayload | null} */
    let notesPayload = null;
    let dirty = false;

    /**
     * @returns {NotesPayload}
     */
    function emptyNotesPayload() {
      return { version: STORAGE_VERSION, notes: {} };
    }

    /**
     * @returns {NotesPayload}
     */
    function loadAllNotes() {
      if (!storageReady) return emptyNotesPayload();
      try {
        const raw = localStorage.getItem(STORAGE_NAMESPACE);
        if (!raw) {
          return emptyNotesPayload();
        }
        const parsed = JSON.parse(raw);
        if (
          typeof parsed !== "object" ||
          parsed === null ||
          typeof parsed.version !== "number" ||
          typeof parsed.notes !== "object"
        ) {
          return emptyNotesPayload();
        }
        return /** @type {NotesPayload} */ (parsed);
      } catch (error) {
        console.warn("Notes storage unavailable", error);
        storageReady = false;
        return emptyNotesPayload();
      }
    }

    /**
     * @param {NotesPayload} payload
     */
    function persistAllNotes(payload) {
      if (!storageReady) return;
      try {
        localStorage.setItem(STORAGE_NAMESPACE, JSON.stringify(payload));
      } catch (error) {
        console.warn("Failed to persist notes", error);
        storageReady = false;
        setStatus("Saving failed: storage is unavailable.");
        textarea.setAttribute("readonly", "true");
        textarea.classList.add("note-field--readonly");
      }
    }

    /**
     * @returns {NoteEntry}
     */
    function loadCurrentNote() {
      if (!notesPayload) {
        notesPayload = loadAllNotes();
      }
      const existing = notesPayload.notes[noteKey];
      if (existing) return existing;
      return {
        id: noteKey,
        type: noteType,
        title: noteTitle,
        content: "",
        updatedAt: new Date().toISOString(),
      };
    }

    /**
     * @param {string} content
     */
    function saveCurrentNote(content) {
      if (!notesPayload) {
        notesPayload = loadAllNotes();
      }
      notesPayload.notes[noteKey] = {
        id: noteKey,
        type: noteType,
        title: noteTitle,
        content,
        updatedAt: new Date().toISOString(),
      };
      persistAllNotes(notesPayload);
    }

    /**
     * @param {string} message
     */
    function setStatus(message) {
      status.textContent = message;
    }

    /**
     * @param {string} message
     */
    function setMeta(message) {
      meta.textContent = message;
    }

    /**
     * @param {string} value
     */
    function sanitizeForPreview(value) {
      const temp = document.createElement("div");
      temp.textContent = value;
      return temp.innerHTML;
    }

    /**
     * @param {string} value
     */
    function updatePreview(value) {
      const sanitized = sanitizeForPreview(value);
      preview.innerHTML = sanitized;
    }

    /**
     * @param {string} iso
     */
    function formatTimestamp(iso) {
      const date = new Date(iso);
      if (Number.isNaN(date.getTime())) {
        return "";
      }
      return date.toLocaleString(undefined, {
        dateStyle: "short",
        timeStyle: "short",
      });
    }

    /**
     * @param {NoteEntry | null} note
     */
    function updateMeta(note) {
      if (!note || !note.content.trim()) {
        setMeta("No saved note yet.");
        return;
      }
      const formatted = formatTimestamp(note.updatedAt);
      setMeta(formatted ? `Saved ${formatted}` : "Saved locally.");
    }

    function refreshFromStorage() {
      const note = loadCurrentNote();
      textarea.value = note.content;
      updatePreview(note.content);
      dirty = false;
      updateMeta(note);
      setStatus(
        storageReady
          ? note.content
            ? "Note loaded from local storage."
            : "Start writing to create a local note, then save."
          : "Local storage is unavailable; notes stay on this page only."
      );

      if (!storageReady) {
        textarea.setAttribute("readonly", "true");
        textarea.classList.add("note-field--readonly");
        exportButton.setAttribute("disabled", "true");
        saveButton.setAttribute("disabled", "true");
      }
    }

    textarea.addEventListener("input", () => {
      const value = textarea.value;
      updatePreview(value);
      if (!storageReady) {
        setStatus("Storage unavailable; notes won't persist.");
        return;
      }
      dirty = true;
      setStatus("Unsaved changes. Remember to save.");
    });

    saveButton.addEventListener("click", () => {
      if (!storageReady) {
        setStatus("Cannot save: storage unavailable.");
        return;
      }
      if (!dirty) {
        setStatus("Nothing new to save.");
        return;
      }
      const value = textarea.value;
      saveCurrentNote(value);
      const note = loadCurrentNote();
      dirty = false;
      updateMeta(note);
      setStatus(
        value.trim().length ? "Note saved locally." : "Cleared note."
      );
    });

    exportButton.addEventListener("click", () => {
      if (!storageReady) {
        setStatus("Nothing to export yet.");
        return;
      }
      const payload = notesPayload ?? loadAllNotes();
      const blob = new Blob([JSON.stringify(payload, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement("a");
      const timestamp = new Date().toISOString().replace(/[:]/g, "-");
      anchor.href = url;
      anchor.download = `improv-toolbox-notes-${timestamp}.json`;
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
      window.setTimeout(() => URL.revokeObjectURL(url), 2000);
      setStatus("Exported notes to a JSON file.");
    });

    refreshFromStorage();

    window.addEventListener("pageshow", () => {
      if (storageReady) {
        notesPayload = null;
        refreshFromStorage();
      }
    });

    window.addEventListener("storage", (event) => {
      if (event.key === STORAGE_NAMESPACE) {
        notesPayload = null;
        refreshFromStorage();
        setStatus("Note updated from another tab.");
      }
    });
  });

  /**
   * @typedef {Object} NoteEntry
   * @property {string} id
   * @property {string} type
   * @property {string} title
   * @property {string} content
   * @property {string} updatedAt
   */

  /**
   * @typedef {Object} NotesPayload
   * @property {number} version
   * @property {Record<string, NoteEntry>} notes
   */
</script>
