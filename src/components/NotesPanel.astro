---
interface Props {
  contentId: string;
  contentType: string;
  contentTitle: string;
}
const { contentId, contentType, contentTitle } = Astro.props as Props;
const noteKey = `${contentType}:${contentId}`;
---

<section
  class="notes-panel"
  data-note-root
  data-note-key={noteKey}
  data-note-title={contentTitle}
  data-note-type={contentType}
>
  <h2>Your notes</h2>
  <div class="note-history" data-note-history hidden>
    <div class="note-history__header">
      <h3>Saved notes</h3>
      <p class="note-history__helper">
        Reopen anything you've captured for this piece. Updating a note keeps
        the original saved time so you can see when you first captured it.
      </p>
    </div>
    <ul class="note-list" data-note-list></ul>
  </div>
  <p class="note-helper">
    Notes live on your device first. We'll keep them ready for optional sync
    later.
  </p>
  <label class="note-field">
    <span class="note-field__label">Markdown-friendly note</span>
    <textarea
      rows="8"
      placeholder="Capture how you adapt this content to your troupe..."
      aria-describedby={`note-status-${noteKey}`}></textarea>
  </label>
  <p class="note-meta" data-note-meta></p>
  <div class="note-toolbar">
    <div class="note-toolbar__actions">
      <button
        type="button"
        class="note-button note-button--primary"
        data-note-save
      >
        Save note
      </button>
      <button
        type="button"
        class="note-button note-button--ghost"
        data-note-clear
      >
        Clear draft
      </button>
      <button
        type="button"
        class="note-button note-button--outline"
        data-note-export
      >
        Export all notes
      </button>
    </div>
    <span
      id={`note-status-${noteKey}`}
      role="status"
      class="note-status"
      aria-live="polite"></span>
  </div>
  <details class="note-preview">
    <summary>Preview</summary>
    <div data-note-preview></div>
  </details>
</section>

<style>
  .notes-panel {
    margin-top: clamp(2.5rem, 6vw, 3.5rem);
    background: color-mix(
      in srgb,
      var(--surface-panel, #221721) 92%,
      transparent
    );
    border-radius: var(--radius-md, 28px);
    padding: clamp(1.75rem, 5vw, 3rem);
    border: 1px solid
      color-mix(
        in srgb,
        var(--color-accent, #ff2f55) 16%,
        rgba(255, 255, 255, 0.08)
      );
    box-shadow: var(--shadow-soft, 0 18px 42px rgba(5, 2, 8, 0.45));
    display: grid;
    gap: 1.25rem;
  }

  .notes-panel h2 {
    margin: 0;
    font-size: clamp(1.4rem, 3vw, 1.6rem);
  }

  .note-helper {
    margin: 0;
    color: color-mix(in srgb, var(--color-muted, #cbbfca) 85%, black 15%);
    font-size: 0.95rem;
  }

  .note-field {
    display: grid;
    gap: 0.5rem;
  }

  .note-field__label {
    font-size: 0.85rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: color-mix(
      in srgb,
      var(--color-muted-strong, #f1d5dc) 70%,
      white 30%
    );
  }

  .note-field textarea {
    width: 100%;
    resize: vertical;
    min-height: 10rem;
    border-radius: 1rem;
    border: 1px solid rgba(255, 255, 255, 0.12);
    padding: 1rem 1.1rem;
    font-size: 1rem;
    line-height: 1.5;
    background: color-mix(
      in srgb,
      var(--surface-color, #161018) 82%,
      black 18%
    );
    color: var(--color-text, #f9f6f8);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
    transition:
      border-color 0.2s ease,
      box-shadow 0.2s ease;
  }

  .note-field textarea:focus-visible {
    outline: none;
    border-color: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 55%,
      transparent
    );
    box-shadow: 0 0 0 2px rgba(255, 71, 97, 0.3);
  }

  .note-field textarea.note-field--readonly {
    cursor: not-allowed;
    opacity: 0.6;
  }

  .note-meta {
    margin: 0;
    font-size: 0.9rem;
    color: color-mix(in srgb, var(--color-muted, #cbbfca) 80%, black 20%);
  }

  .note-toolbar {
    display: grid;
    gap: 0.65rem;
    align-items: start;
  }

  .note-toolbar__actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.65rem;
  }

  .note-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.35rem;
    padding: 0.6rem 1.2rem;
    border-radius: var(--radius-md);
    border: 1px solid transparent;
    font-size: 0.95rem;
    font-weight: 600;
    letter-spacing: 0.03em;
    text-transform: uppercase;
    transition:
      transform 0.2s ease,
      box-shadow 0.2s ease,
      background 0.2s ease,
      border-color 0.2s ease,
      color 0.2s ease;
    background: color-mix(
      in srgb,
      var(--surface-raised, #1f1521) 68%,
      black 32%
    );
    color: var(--color-heading, #fff5f7);
    box-shadow: 0 10px 24px rgba(10, 4, 12, 0.35);
  }

  .note-button:hover,
  .note-button:focus-visible {
    transform: translateY(-2px);
    box-shadow: 0 14px 32px rgba(15, 6, 18, 0.45);
  }

  .note-button:disabled {
    opacity: 0.45;
    pointer-events: none;
    box-shadow: none;
    transform: none;
  }

  .note-button--primary {
    background: linear-gradient(
      135deg,
      var(--color-accent, #ff2f55) 0%,
      #ff6b82 100%
    );
    color: #140408;
    border: none;
    box-shadow: 0 18px 38px rgba(255, 63, 94, 0.45);
  }

  .note-button--primary:hover,
  .note-button--primary:focus-visible {
    box-shadow: 0 22px 46px rgba(255, 63, 94, 0.55);
  }

  .note-button--ghost {
    background: rgba(255, 255, 255, 0.05);
    border-color: rgba(255, 255, 255, 0.12);
    color: color-mix(in srgb, var(--color-muted, #cbbfca) 90%, white 10%);
  }

  .note-button--outline {
    background: color-mix(
      in srgb,
      var(--surface-color, #161018) 75%,
      transparent
    );
    border-color: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 45%,
      transparent
    );
    color: var(--color-accent-soft, #ff536c);
  }

  .note-button--outline:hover,
  .note-button--outline:focus-visible {
    background: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 18%,
      var(--surface-raised, #1f1521) 82%
    );
    border-color: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 55%,
      transparent
    );
  }

  .note-button--danger {
    background: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 12%,
      transparent
    );
    border-color: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 45%,
      transparent
    );
    color: var(--color-accent-soft, #ff536c);
  }

  .note-button--danger:hover,
  .note-button--danger:focus-visible {
    background: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 26%,
      var(--surface-raised, #1f1521) 74%
    );
    border-color: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 60%,
      transparent
    );
    color: #140408;
  }

  .note-status {
    min-height: 1.5rem;
    font-size: 0.9rem;
    color: color-mix(in srgb, var(--color-muted, #cbbfca) 85%, black 15%);
  }

  @media (min-width: 720px) {
    .note-toolbar {
      grid-template-columns: auto 1fr;
      align-items: center;
    }

    .note-status {
      text-align: right;
    }
  }

  .note-preview {
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 1rem;
    padding: 0.75rem 1rem;
    background: color-mix(
      in srgb,
      var(--surface-raised, #1f1521) 84%,
      black 16%
    );
    box-shadow: 0 12px 28px rgba(6, 2, 10, 0.4);
  }

  .note-preview summary {
    cursor: pointer;
    font-weight: 600;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    color: var(--color-muted-strong, #f1d5dc);
  }

  .note-preview summary::marker {
    display: none;
  }

  .note-preview summary::-webkit-details-marker {
    display: none;
  }

  .note-preview[open] summary {
    color: var(--color-heading, #fff5f7);
  }

  .note-preview div {
    padding: 0.75rem 0 0;
    display: grid;
    gap: 0.75rem;
  }

  .note-preview div :is(pre, code) {
    font-family: var(
      --font-mono,
      "JetBrains Mono",
      "Fira Code",
      ui-monospace,
      SFMono-Regular,
      Menlo,
      Monaco,
      Consolas,
      "Liberation Mono",
      "Courier New",
      monospace
    );
  }

  .note-history {
    display: grid;
    gap: 1.1rem;
  }

  .note-history__header {
    display: grid;
    gap: 0.5rem;
  }

  .note-history__header h3 {
    margin: 0;
    font-size: clamp(1.1rem, 2.8vw, 1.3rem);
    letter-spacing: 0.04em;
    text-transform: uppercase;
  }

  .note-history__helper {
    margin: 0;
    color: color-mix(in srgb, var(--color-muted, #cbbfca) 85%, black 15%);
    font-size: 0.9rem;
  }

  .note-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: grid;
    gap: 1.15rem;
  }

  :global(.note-item) {
    position: relative;
    border-radius: var(--radius-md, 28px);
    padding: 1.15rem 1.25rem 1.2rem;
    display: grid;
    gap: 0.9rem;
    background: color-mix(
      in srgb,
      var(--surface-panel, #221721) 88%,
      transparent
    );
    border: 1px solid rgba(255, 255, 255, 0.08);
    box-shadow: 0 20px 42px rgba(8, 4, 12, 0.4);
    overflow: hidden;
    transition:
      transform 0.22s ease,
      box-shadow 0.22s ease,
      border-color 0.22s ease;
  }

  :global(.note-item)::before {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: radial-gradient(
      160% 160% at 0% 0%,
      rgba(255, 71, 97, 0.16),
      transparent 68%
    );
    opacity: 0.6;
  }

  @media (hover: hover) {
    :global(.note-item:hover) {
      transform: translateY(-2px);
      border-color: color-mix(
        in srgb,
        var(--color-accent, #ff2f55) 24%,
        transparent
      );
      box-shadow: 0 24px 48px rgba(8, 4, 12, 0.48);
    }
  }

  :global(.note-item__header) {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.75rem;
    padding: 0.4rem 0.6rem;
    border-radius: 999px;
    background: color-mix(
      in srgb,
      var(--surface-glass, #241521) 78%,
      transparent
    );
    border: 1px solid rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(12px) saturate(140%);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
    position: relative;
    z-index: 1;
  }

  :global(.note-item__meta) {
    display: flex;
    align-items: center;
    gap: 0.55rem;
    flex-wrap: wrap;
    min-width: 0;
  }

  :global(.note-item__timestamp) {
    display: flex;
    flex-direction: column;
    gap: 0.15rem;
    font-size: 0.9rem;
    font-weight: 600;
    letter-spacing: 0.02em;
    color: color-mix(in srgb, var(--color-heading, #fff5f7) 85%, white 15%);
    white-space: nowrap;
    min-width: 0;
  }

  :global(.note-item__timestamp[data-label])::before {
    content: attr(data-label);
    font-size: 0.6rem;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    color: color-mix(in srgb, var(--color-muted, #cbbfca) 78%, black 22%);
    opacity: 0.85;
  }

  :global(.note-item__updated) {
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.2rem 0.65rem;
    border-radius: 999px;
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: color-mix(
      in srgb,
      var(--surface-glass, #241521) 75%,
      transparent
    );
    font-size: 0.75rem;
    letter-spacing: 0.03em;
    color: color-mix(
      in srgb,
      var(--color-muted-strong, #f1d5dc) 75%,
      white 25%
    );
    white-space: nowrap;
  }

  :global(.note-item__updated[data-label])::before {
    content: attr(data-label);
    font-size: 0.6rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: color-mix(in srgb, var(--color-muted, #cbbfca) 75%, black 25%);
  }

  @media (max-width: 520px) {
    :global(.note-item__header) {
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    :global(.note-item__timestamp) {
      white-space: normal;
    }

    :global(.note-item__actions) {
      width: 100%;
      justify-content: flex-end;
    }
  }

  :global(.note-item__actions) {
    display: inline-flex;
    gap: 0.35rem;
    flex-shrink: 0;
  }

  :global(.note-icon-button) {
    --note-icon-size: 1rem;
    width: 1.85rem;
    height: 1.85rem;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border-radius: 999px;
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: color-mix(
      in srgb,
      var(--surface-glass, #241521) 72%,
      transparent
    );
    color: color-mix(
      in srgb,
      var(--color-muted-strong, #f1d5dc) 82%,
      white 18%
    );
    box-shadow: 0 8px 18px rgba(8, 4, 12, 0.35);
    transition:
      transform 0.18s ease,
      box-shadow 0.18s ease,
      background 0.18s ease,
      border-color 0.18s ease,
      color 0.18s ease;
    cursor: pointer;
    backdrop-filter: blur(10px) saturate(160%);
    position: relative;
    overflow: hidden;
  }

  :global(.note-icon-button)::after {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06);
    pointer-events: none;
  }

  :global(.note-icon-button:hover),
  :global(.note-icon-button:focus-visible) {
    transform: translateY(-1px) scale(1.04);
    outline: none;
    box-shadow: 0 12px 26px rgba(12, 5, 16, 0.45);
  }

  :global(.note-icon-button) svg {
    width: var(--note-icon-size);
    height: var(--note-icon-size);
  }

  :global(.note-icon-button--edit) {
    border-color: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 24%,
      transparent
    );
    color: color-mix(in srgb, var(--color-accent-soft, #ff536c) 80%, white 20%);
  }

  :global(.note-icon-button--edit:hover),
  :global(.note-icon-button--edit:focus-visible) {
    background: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 16%,
      var(--surface-glass, #241521) 84%
    );
    border-color: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 58%,
      transparent
    );
    color: #1a050b;
  }

  :global(.note-icon-button--delete) {
    border-color: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 20%,
      transparent
    );
    color: color-mix(in srgb, var(--color-warning, #ffb3b3) 55%, white 45%);
    background: color-mix(
      in srgb,
      var(--surface-color, #161018) 78%,
      rgba(255, 41, 62, 0.08)
    );
  }

  :global(.note-icon-button--delete:hover),
  :global(.note-icon-button--delete:focus-visible) {
    background: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 24%,
      #1a0d12 76%
    );
    border-color: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 62%,
      transparent
    );
    color: #1a050b;
  }

  :global(.note-icon-button:disabled) {
    opacity: 0.4;
    pointer-events: none;
    transform: none;
    box-shadow: none;
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  :global(.note-item--editing) {
    border-color: rgba(255, 83, 108, 0.45);
    box-shadow:
      0 0 0 1px rgba(255, 83, 108, 0.35),
      0 24px 48px rgba(255, 71, 97, 0.35);
  }

  :global(.note-item--editing)::before {
    opacity: 0.9;
    background: radial-gradient(
      140% 120% at 10% 0%,
      rgba(255, 83, 108, 0.35),
      transparent 68%
    );
  }

  :global(.note-item--editing .note-item__timestamp) {
    color: var(--color-accent-soft, #ff536c);
  }

  :global(.note-item--editing .note-item__header) {
    border-color: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 45%,
      transparent
    );
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12);
  }

  :global(.note-item--editing .note-item__updated) {
    border-color: color-mix(
      in srgb,
      var(--color-accent, #ff2f55) 42%,
      transparent
    );
    color: color-mix(in srgb, var(--color-heading, #fff5f7) 85%, white 15%);
  }

  :global(.note-item__body) {
    margin: 0;
    display: grid;
    gap: 0.5rem;
    position: relative;
    z-index: 1;
  }

  .note-preview div p,
  :global(.note-item__body) p {
    margin: 0;
  }

  .note-preview div pre,
  :global(.note-item__body) pre {
    padding: 0.75rem;
    border-radius: 0.35rem;
    background: rgba(255, 255, 255, 0.06);
  }

  .note-preview div :is(ul, ol),
  :global(.note-item__body) :is(ul, ol) {
    margin: 0;
    padding-left: 1.25rem;
    display: grid;
    gap: 0.35rem;
  }

  .note-preview div blockquote,
  :global(.note-item__body) blockquote {
    margin: 0;
    padding-left: 1rem;
    border-left: 3px solid rgba(255, 255, 255, 0.12);
  }

  .note-preview div img,
  :global(.note-item__body) img {
    max-width: 100%;
    height: auto;
  }
</style>

<script type="module" lang="ts">
  const STORAGE_NAMESPACE = "improv-toolbox:notes";
  const STORAGE_VERSION = 2;
  const storageSupported = (() => {
    if (typeof window === "undefined" || !("localStorage" in window)) {
      return false;
    }
    try {
      const probeKey = "improv-toolbox:notes-probe";
      localStorage.setItem(probeKey, "ok");
      localStorage.removeItem(probeKey);
      return true;
    } catch (error) {
      console.warn("Local storage is not available for notes", error);
      return false;
    }
  })();

  const panels = Array.from(document.querySelectorAll("[data-note-root]"));

  panels.forEach((panel) => {
    const textarea = /** @type {HTMLTextAreaElement | null} */ (
      panel.querySelector("textarea")
    );
    const preview = /** @type {HTMLDivElement | null} */ (
      panel.querySelector("[data-note-preview]")
    );
    const status = /** @type {HTMLSpanElement | null} */ (
      panel.querySelector(".note-status")
    );
    const saveButton = /** @type {HTMLButtonElement | null} */ (
      panel.querySelector("[data-note-save]")
    );
    const exportButton = /** @type {HTMLButtonElement | null} */ (
      panel.querySelector("[data-note-export]")
    );
    const clearButton = /** @type {HTMLButtonElement | null} */ (
      panel.querySelector("[data-note-clear]")
    );
    const meta = /** @type {HTMLParagraphElement | null} */ (
      panel.querySelector("[data-note-meta]")
    );
    const history = /** @type {HTMLDivElement | null} */ (
      panel.querySelector("[data-note-history]")
    );
    const list = /** @type {HTMLUListElement | null} */ (
      panel.querySelector("[data-note-list]")
    );
    if (
      !textarea ||
      !preview ||
      !status ||
      !exportButton ||
      !saveButton ||
      !meta ||
      !history ||
      !list ||
      !clearButton
    ) {
      return;
    }

    let noteKey = panel.dataset.noteKey ?? "";
    let noteTitle = panel.dataset.noteTitle ?? "";
    let noteType = panel.dataset.noteType ?? "content";

    let storageReady = storageSupported;
    /** @type {NotesPayload | null} */
    let notesPayload = null;
    const defaultSaveLabel = saveButton.textContent.trim() || "Save note";
    saveButton.textContent = defaultSaveLabel;
    /** @type {string | null} */
    let editingNoteId = null;
    /** @type {string | null} */
    let draftBeforeEdit = null;

    /**
     * @param {{ key?: string; title?: string; type?: string } | undefined | null} context
     */
    function applyNoteContext(context) {
      if (!context || typeof context !== "object") {
        return;
      }
      const proposedKey =
        typeof context.key === "string" ? context.key.trim() : "";
      if (!proposedKey) {
        return;
      }
      const proposedTitle =
        typeof context.title === "string" ? context.title : noteTitle;
      const proposedType =
        typeof context.type === "string" && context.type
          ? context.type
          : noteType;

      if (editingNoteId) {
        cancelEdit(false);
      } else {
        draftBeforeEdit = null;
      }

      panel.dataset.noteKey = proposedKey;
      panel.dataset.noteTitle = proposedTitle;
      panel.dataset.noteType = proposedType;

      noteKey = proposedKey;
      noteTitle = proposedTitle;
      noteType = proposedType;

      notesPayload = null;
      refreshFromStorage();
    }

    function updateSaveButtonLabel() {
      saveButton.textContent = editingNoteId ? "Update note" : defaultSaveLabel;
    }

    function updateSaveButtonState(value) {
      saveButton.disabled = !storageReady || !value.trim();
    }

    function restoreDraftAfterEdit() {
      const draftContent = draftBeforeEdit ?? "";
      draftBeforeEdit = null;
      textarea.value = draftContent;
      updatePreview(draftContent);
      updateSaveButtonState(draftContent);
    }

    function highlightEditingItem() {
      const nodes = Array.from(list.querySelectorAll(".note-item"));
      for (const node of nodes) {
        const element = /** @type {HTMLLIElement} */ (node);
        const currentId = element.dataset.noteId ?? "";
        if (editingNoteId && currentId === editingNoteId) {
          element.classList.add("note-item--editing");
        } else {
          element.classList.remove("note-item--editing");
        }
      }
    }

    /**
     * @returns {NotesPayload}
     */
    function emptyNotesPayload() {
      return { version: STORAGE_VERSION, notes: {}, drafts: {} };
    }

    /**
     * @param {Partial<NotesPayloadLegacy>} payload
     * @returns {NotesPayload}
     */
    function migratePayload(payload) {
      if (
        !payload ||
        typeof payload !== "object" ||
        typeof payload.notes !== "object" ||
        payload.notes === null
      ) {
        return emptyNotesPayload();
      }

      if (payload.version === STORAGE_VERSION && "drafts" in payload) {
        return /** @type {NotesPayload} */ (payload);
      }

      const migrated = emptyNotesPayload();
      migrated.version = STORAGE_VERSION;

      for (const [key, value] of Object.entries(payload.notes)) {
        if (!value || typeof value !== "object") continue;
        const items = [];
        const content = typeof value.content === "string" ? value.content : "";
        const updatedAt =
          typeof value.updatedAt === "string"
            ? value.updatedAt
            : new Date().toISOString();
        if (content.trim()) {
          items.push({
            id: `${key}:${updatedAt}`,
            content,
            savedAt: updatedAt,
            updatedAt,
          });
        } else if (content) {
          migrated.drafts[key] = {
            content,
            updatedAt,
          };
        }
        migrated.notes[key] = {
          id: key,
          type: typeof value.type === "string" ? value.type : "content",
          title: typeof value.title === "string" ? value.title : "",
          items,
          updatedAt,
        };
      }

      return migrated;
    }

    /**
     * @returns {NotesPayload}
     */
    function loadAllNotes() {
      if (!storageReady) return emptyNotesPayload();
      try {
        const raw = localStorage.getItem(STORAGE_NAMESPACE);
        if (!raw) {
          return emptyNotesPayload();
        }
        const parsed = JSON.parse(raw);
        const migrated = migratePayload(
          /** @type {Partial<NotesPayloadLegacy>} */ (parsed)
        );
        if (migrated.version !== STORAGE_VERSION) {
          migrated.version = STORAGE_VERSION;
          persistAllNotes(migrated);
        }
        return migrated;
      } catch (error) {
        console.warn("Notes storage unavailable", error);
        storageReady = false;
        return emptyNotesPayload();
      }
    }

    /**
     * @param {NotesPayload} payload
     */
    function persistAllNotes(payload) {
      if (!storageReady) return;
      try {
        localStorage.setItem(STORAGE_NAMESPACE, JSON.stringify(payload));
      } catch (error) {
        console.warn("Failed to persist notes", error);
        storageReady = false;
        setStatus("Saving failed: storage is unavailable.");
        textarea.setAttribute("readonly", "true");
        textarea.classList.add("note-field--readonly");
        exportButton.setAttribute("disabled", "true");
        saveButton.setAttribute("disabled", "true");
        clearButton.setAttribute("disabled", "true");
      }
    }

    function ensurePayload() {
      if (!notesPayload) {
        notesPayload = loadAllNotes();
      }
      return notesPayload;
    }

    /**
     * @returns {NoteCollection}
     */
    function loadCollection() {
      const payload = ensurePayload();
      const existing = payload.notes[noteKey];
      if (existing) {
        return existing;
      }
      const collection = {
        id: noteKey,
        type: noteType,
        title: noteTitle,
        items: [],
        updatedAt: new Date().toISOString(),
      };
      payload.notes[noteKey] = collection;
      return collection;
    }

    /**
     * @returns {DraftEntry | null}
     */
    function loadDraft() {
      const payload = ensurePayload();
      return payload.drafts[noteKey] ?? null;
    }

    /**
     * @param {string} content
     */
    function saveDraft(content) {
      const payload = ensurePayload();
      if (!content) {
        delete payload.drafts[noteKey];
      } else {
        payload.drafts[noteKey] = {
          content,
          updatedAt: new Date().toISOString(),
        };
      }
      persistAllNotes(payload);
    }

    function clearDraft(shouldPersist = true) {
      const payload = ensurePayload();
      if (payload.drafts[noteKey]) {
        delete payload.drafts[noteKey];
        if (shouldPersist) {
          persistAllNotes(payload);
        }
      }
      return payload;
    }

    /**
     * @param {NoteEntry} entry
     */
    function beginEdit(entry) {
      if (!storageReady) {
        setStatus("Cannot edit: storage unavailable.");
        return;
      }
      if (draftBeforeEdit === null) {
        const draft = loadDraft();
        if (draft && typeof draft.content === "string") {
          draftBeforeEdit = draft.content;
        } else {
          draftBeforeEdit = textarea.value;
        }
      }
      editingNoteId = entry.id;
      updateSaveButtonLabel();
      textarea.value = entry.content;
      updatePreview(entry.content);
      updateSaveButtonState(entry.content);
      setStatus("Editing existing note. Click save to update it.");
      textarea.focus();
      highlightEditingItem();
    }

    function cancelEdit(restoreDraft = true) {
      if (!editingNoteId) {
        return;
      }
      editingNoteId = null;
      updateSaveButtonLabel();
      if (restoreDraft) {
        restoreDraftAfterEdit();
      } else {
        draftBeforeEdit = null;
        updatePreview(textarea.value);
        updateSaveButtonState(textarea.value);
      }
      highlightEditingItem();
    }

    function deleteNote(noteId) {
      if (!storageReady) {
        setStatus("Cannot delete: storage unavailable.");
        return;
      }
      if (!window.confirm("Delete this note?")) {
        return;
      }
      const payload = ensurePayload();
      const collection = loadCollection();
      const index = collection.items.findIndex((item) => item.id === noteId);
      if (index === -1) {
        setStatus("Note already removed.");
        renderNoteList(collection);
        highlightEditingItem();
        return;
      }
      collection.items.splice(index, 1);
      const timestamp = new Date().toISOString();
      collection.updatedAt = timestamp;
      payload.notes[noteKey] = collection;
      if (editingNoteId === noteId) {
        cancelEdit();
      }
      renderNoteList(collection);
      updateMeta(collection);
      persistAllNotes(payload);
      setStatus("Note deleted.");
    }

    /**
     * @param {string} message
     */
    function setStatus(message) {
      status.textContent = message;
    }

    /**
     * @param {string} message
     */
    function setMeta(message) {
      meta.textContent = message;
    }

    /**
     * @param {string} value
     * @returns {string}
     */
    function escapeHtml(value) {
      const temp = document.createElement("div");
      temp.textContent = value;
      return temp.innerHTML;
    }

    /**
     * @param {string} value
     * @returns {string}
     */
    function escapeAttribute(value) {
      return value
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    /**
     * @param {string} value
     * @returns {string}
     */
    function renderInlineMarkdown(value) {
      let result = "";
      let buffer = "";

      /**
       * @param {string} chunk
       */
      function flushText(chunk) {
        if (!chunk) return;
        result += escapeHtml(chunk);
      }

      /**
       * @param {string} content
       */
      function appendFormatted(content) {
        result += content;
      }

      /**
       * @param {string} chunk
       */
      function flushBuffer(chunk) {
        if (!chunk) return;
        flushText(chunk);
      }

      /**
       * @param {string} text
       * @returns {string}
       */
      function recurse(text) {
        return renderInlineMarkdown(text);
      }

      for (let index = 0; index < value.length; ) {
        const char = value[index];

        if (char === "`") {
          const closing = value.indexOf("`", index + 1);
          if (closing !== -1) {
            flushBuffer(buffer);
            buffer = "";
            const codeContent = value.slice(index + 1, closing);
            appendFormatted(`<code>${escapeHtml(codeContent)}</code>`);
            index = closing + 1;
            continue;
          }
        }

        if (
          (char === "*" && value[index + 1] === "*") ||
          (char === "_" && value[index + 1] === "_")
        ) {
          const marker = value.slice(index, index + 2);
          const closing = value.indexOf(marker, index + 2);
          if (closing !== -1) {
            flushBuffer(buffer);
            buffer = "";
            const inner = value.slice(index + 2, closing);
            appendFormatted(`<strong>${recurse(inner)}</strong>`);
            index = closing + 2;
            continue;
          }
        }

        if (char === "~" && value[index + 1] === "~") {
          const closing = value.indexOf("~~", index + 2);
          if (closing !== -1) {
            flushBuffer(buffer);
            buffer = "";
            const inner = value.slice(index + 2, closing);
            appendFormatted(`<del>${recurse(inner)}</del>`);
            index = closing + 2;
            continue;
          }
        }

        if (char === "*" || char === "_") {
          const closing = value.indexOf(char, index + 1);
          if (closing !== -1) {
            const inner = value.slice(index + 1, closing);
            if (inner.trim()) {
              flushBuffer(buffer);
              buffer = "";
              appendFormatted(`<em>${recurse(inner)}</em>`);
              index = closing + 1;
              continue;
            }
          }
        }

        if (char === "[") {
          const closingText = value.indexOf("]", index + 1);
          if (closingText !== -1 && value[closingText + 1] === "(") {
            const closingUrl = value.indexOf(")", closingText + 2);
            if (closingUrl !== -1) {
              const text = value.slice(index + 1, closingText);
              const href = value.slice(closingText + 2, closingUrl).trim();
              if (/^https?:\/\//i.test(href)) {
                flushBuffer(buffer);
                buffer = "";
                appendFormatted(
                  `<a href="${escapeAttribute(href)}" rel="noreferrer noopener">${recurse(
                    text
                  )}</a>`
                );
                index = closingUrl + 1;
                continue;
              }
            }
          }
        }

        if (char === "!" && value[index + 1] === "[") {
          const closingAlt = value.indexOf("]", index + 2);
          if (closingAlt !== -1 && value[closingAlt + 1] === "(") {
            const closingUrl = value.indexOf(")", closingAlt + 2);
            if (closingUrl !== -1) {
              const alt = value.slice(index + 2, closingAlt);
              const src = value.slice(closingAlt + 2, closingUrl).trim();
              if (/^https?:\/\//i.test(src)) {
                flushBuffer(buffer);
                buffer = "";
                appendFormatted(
                  `<img src="${escapeAttribute(src)}" alt="${escapeAttribute(
                    alt
                  )}" loading="lazy" />`
                );
                index = closingUrl + 1;
                continue;
              }
            }
          }
        }

        buffer += char;
        index += 1;
      }

      flushBuffer(buffer);

      return result;
    }

    /**
     * @param {string} value
     */
    function updatePreview(value) {
      preview.innerHTML = renderMarkdown(value);
    }

    /**
     * @param {string} value
     * @returns {string}
     */
    function renderMarkdown(value) {
      if (!value) {
        return "";
      }

      const lines = value.replace(/\r\n?/g, "\n").split("\n");
      const root = document.createElement("div");
      let listElement = null;
      /** @type {"ul" | "ol" | ""} */
      let listType = "";
      let paragraphBuffer = [];
      let blockquoteBuffer = [];
      let inCodeBlock = false;
      let codeLanguage = "";
      /** @type {string[]} */
      const codeLines = [];

      function ensureList(type) {
        if (!listElement || listType !== type) {
          closeList();
          listElement = document.createElement(type);
          listType = type;
          root.appendChild(listElement);
        }
        return listElement;
      }

      function closeList() {
        listElement = null;
        listType = "";
      }

      function flushParagraph() {
        if (paragraphBuffer.length === 0) return;
        const paragraph = document.createElement("p");
        paragraph.innerHTML = paragraphBuffer
          .map((line) => renderInlineMarkdown(line))
          .join("<br>");
        root.appendChild(paragraph);
        paragraphBuffer = [];
      }

      function flushBlockquote() {
        if (blockquoteBuffer.length === 0) return;
        const blockquote = document.createElement("blockquote");
        blockquote.innerHTML = blockquoteBuffer
          .map((line) => renderInlineMarkdown(line))
          .join("<br>");
        root.appendChild(blockquote);
        blockquoteBuffer = [];
      }

      function flushCodeBlock() {
        const pre = document.createElement("pre");
        const code = document.createElement("code");
        if (codeLanguage) {
          const safeLanguage = codeLanguage
            .toLowerCase()
            .replace(/[^a-z0-9+_-]+/g, "")
            .replace(/\s+/g, "");
          if (safeLanguage) {
            code.className = `language-${safeLanguage}`;
          }
        }
        code.textContent = codeLines.join("\n");
        pre.appendChild(code);
        root.appendChild(pre);
        codeLines.length = 0;
        codeLanguage = "";
      }

      for (const rawLine of lines) {
        const trimmed = rawLine.trim();

        if (inCodeBlock) {
          if (trimmed.startsWith("```")) {
            flushCodeBlock();
            inCodeBlock = false;
            continue;
          }
          codeLines.push(rawLine);
          continue;
        }

        if (trimmed.startsWith("```")) {
          flushParagraph();
          flushBlockquote();
          closeList();
          inCodeBlock = true;
          codeLanguage = trimmed.slice(3).trim();
          continue;
        }

        if (!trimmed) {
          flushParagraph();
          flushBlockquote();
          closeList();
          continue;
        }

        const headingMatch = trimmed.match(/^(#{1,6})\s+(.*)$/);
        if (headingMatch) {
          flushParagraph();
          flushBlockquote();
          closeList();
          const level = Math.min(6, headingMatch[1].length);
          const heading = document.createElement(`h${level}`);
          heading.innerHTML = renderInlineMarkdown(headingMatch[2].trim());
          root.appendChild(heading);
          continue;
        }

        const blockquoteMatch = rawLine.match(/^\s*>\s?(.*)$/);
        if (blockquoteMatch) {
          flushParagraph();
          closeList();
          blockquoteBuffer.push(blockquoteMatch[1]);
          continue;
        }
        flushBlockquote();

        const unorderedMatch = rawLine.match(/^\s*([-*+])\s+(.*)$/);
        if (unorderedMatch) {
          flushParagraph();
          flushBlockquote();
          const list = ensureList("ul");
          const item = document.createElement("li");
          item.innerHTML = renderInlineMarkdown(unorderedMatch[2]);
          list.appendChild(item);
          continue;
        }

        const orderedMatch = rawLine.match(/^\s*(\d+)\.\s+(.*)$/);
        if (orderedMatch) {
          flushParagraph();
          flushBlockquote();
          const list = ensureList("ol");
          const item = document.createElement("li");
          item.innerHTML = renderInlineMarkdown(orderedMatch[2]);
          list.appendChild(item);
          continue;
        }

        paragraphBuffer.push(rawLine);
      }

      if (inCodeBlock) {
        flushCodeBlock();
      }

      flushParagraph();
      flushBlockquote();
      closeList();

      return root.innerHTML;
    }

    /**
     * @param {string} iso
     */
    function formatTimestamp(iso) {
      const date = new Date(iso);
      if (Number.isNaN(date.getTime())) {
        return "";
      }
      return date.toLocaleString(undefined, {
        dateStyle: "short",
        timeStyle: "short",
      });
    }

    /**
     * @param {NoteCollection} collection
     */
    function createIconButton(label, variant, pathD) {
      const button = document.createElement("button");
      button.type = "button";
      button.className = `note-icon-button note-icon-button--${variant}`;
      button.setAttribute("aria-label", label);
      button.innerHTML = `
        <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
          <path d="${pathD}" fill="currentColor" />
        </svg>
        <span class="visually-hidden">${label}</span>
      `.trim();
      return button;
    }

    function renderNoteList(collection) {
      list.innerHTML = "";
      if (!collection || collection.items.length === 0) {
        history.setAttribute("hidden", "true");
        return;
      }

      history.removeAttribute("hidden");
      const fragment = document.createDocumentFragment();
      collection.items
        .slice()
        .sort((a, b) => (a.savedAt < b.savedAt ? 1 : -1))
        .forEach((item) => {
          const li = document.createElement("li");
          li.className = "note-item";
          li.dataset.noteId = item.id;
          if (editingNoteId === item.id) {
            li.classList.add("note-item--editing");
          }

          const header = document.createElement("div");
          header.className = "note-item__header";

          const meta = document.createElement("div");
          meta.className = "note-item__meta";

          const timestamp = document.createElement("time");
          timestamp.className = "note-item__timestamp";
          timestamp.dateTime = item.savedAt;
          const formatted = formatTimestamp(item.savedAt);
          timestamp.textContent = formatted || "Saved locally";
          if (formatted) {
            timestamp.dataset.label = "Saved";
            timestamp.setAttribute("aria-label", `Saved on ${formatted}`);
          }

          meta.appendChild(timestamp);

          if (item.updatedAt && item.updatedAt !== item.savedAt) {
            const updated = document.createElement("time");
            updated.className = "note-item__updated";
            updated.dateTime = item.updatedAt;
            const updatedFormatted = formatTimestamp(item.updatedAt);
            updated.textContent = updatedFormatted || "Edited locally";
            if (updatedFormatted) {
              updated.dataset.label = "Edited";
              updated.setAttribute(
                "aria-label",
                `Edited on ${updatedFormatted}`
              );
            }
            meta.appendChild(updated);
          }

          header.appendChild(meta);

          const actions = document.createElement("div");
          actions.className = "note-item__actions";

          const editButton = createIconButton(
            "Edit note",
            "edit",
            "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zm2.92 1.33-1.42-1.42 9.9-9.9 1.41 1.42-9.89 9.9zM20.71 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"
          );
          editButton.addEventListener("click", () => {
            beginEdit(item);
          });

          const deleteButton = createIconButton(
            "Delete note",
            "delete",
            "M6 7h12v12a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V7zm12-2h-3.5l-.71-.71A1 1 0 0 0 13.59 4h-3.18a1 1 0 0 0-.71.29L9 5H5a1 1 0 0 0 0 2h14a1 1 0 0 0 0-2zm-7 5a1 1 0 0 0-1 1v7a1 1 0 0 0 2 0v-7a1 1 0 0 0-1-1zm4 0a1 1 0 0 0-1 1v7a1 1 0 0 0 2 0v-7a1 1 0 0 0-1-1z"
          );
          deleteButton.addEventListener("click", () => {
            deleteNote(item.id);
          });

          actions.appendChild(editButton);
          actions.appendChild(deleteButton);

          header.appendChild(actions);

          const body = document.createElement("div");
          body.className = "note-item__body";
          body.innerHTML = renderMarkdown(item.content);

          li.appendChild(header);
          li.appendChild(body);

          fragment.appendChild(li);
        });

      list.appendChild(fragment);
    }

    /**
     * @param {NoteCollection} collection
     */
    function updateMeta(collection) {
      if (!collection || collection.items.length === 0) {
        setMeta("");
        return;
      }
      const formatted = formatTimestamp(collection.updatedAt);
      const count = collection.items.length;
      setMeta(
        formatted
          ? `${count} saved ${count === 1 ? "note" : "notes"}. Latest ${formatted}.`
          : `${count} saved ${count === 1 ? "note" : "notes"}.`
      );
    }

    function refreshFromStorage() {
      const collection = loadCollection();
      const draft = loadDraft();
      const draftContent = draft?.content ?? "";
      const isEditing = Boolean(editingNoteId);

      if (isEditing) {
        const exists = collection.items.some(
          (item) => item.id === editingNoteId
        );
        if (!exists) {
          cancelEdit();
        }
      }

      if (!editingNoteId) {
        if (!isEditing) {
          textarea.value = draftContent;
        }
      }

      updatePreview(textarea.value);
      updateSaveButtonState(textarea.value);
      renderNoteList(collection);
      updateMeta(collection);
      updateSaveButtonLabel();
      highlightEditingItem();

      let statusMessage = "";
      if (!storageReady) {
        statusMessage =
          "Local storage is unavailable; notes stay on this page only.";
      } else if (editingNoteId) {
        statusMessage = "Editing existing note. Click save to update it.";
      } else if (draftContent) {
        statusMessage =
          "Draft restored. Save to add it to your notes or clear it.";
      } else if (collection.items.length) {
        statusMessage = "Notes loaded from local storage.";
      } else {
        statusMessage = "Start a note and it'll stay here until you save.";
      }

      setStatus(statusMessage);

      if (!storageReady) {
        textarea.setAttribute("readonly", "true");
        textarea.classList.add("note-field--readonly");
        exportButton.setAttribute("disabled", "true");
        saveButton.disabled = true;
        clearButton.setAttribute("disabled", "true");
      }
    }

    textarea.addEventListener("input", () => {
      const value = textarea.value;
      updatePreview(value);
      updateSaveButtonState(value);
      if (!storageReady) {
        setStatus("Storage unavailable; notes won't persist.");
        return;
      }
      if (editingNoteId) {
        setStatus("Editing note. Click save to update it.");
        return;
      }
      saveDraft(value);
      setStatus(
        value.trim()
          ? "Draft saved locally. Click save to add it to your notes."
          : "Draft cleared."
      );
    });

    function saveNote() {
      if (!storageReady) {
        setStatus("Cannot save: storage unavailable.");
        return;
      }
      const value = textarea.value.trim();
      if (!value) {
        setStatus("Write something before saving.");
        return;
      }
      const payload = ensurePayload();
      const collection = loadCollection();
      const savedAt = new Date().toISOString();

      if (editingNoteId) {
        const index = collection.items.findIndex(
          (item) => item.id === editingNoteId
        );
        if (index === -1) {
          cancelEdit();
          setStatus("The note you were editing is no longer available.");
          return;
        }
        const existing = collection.items[index];
        collection.items[index] = {
          ...existing,
          content: value,
          updatedAt: savedAt,
        };
        collection.updatedAt = savedAt;
        payload.notes[noteKey] = collection;
        renderNoteList(collection);
        updateMeta(collection);
        cancelEdit();
        persistAllNotes(payload);
        setStatus("Note updated locally.");
        return;
      }

      const entry = {
        id: `${noteKey}:${savedAt}`,
        content: value,
        savedAt,
        updatedAt: savedAt,
      };
      collection.items.unshift(entry);
      collection.updatedAt = savedAt;
      payload.notes[noteKey] = collection;
      clearDraft(false);
      textarea.value = "";
      updatePreview("");
      updateSaveButtonState("");
      renderNoteList(collection);
      updateMeta(collection);
      persistAllNotes(payload);
      setStatus("Note saved locally.");
    }

    saveButton.addEventListener("click", () => {
      saveNote();
    });

    panel.addEventListener(
      "note:context",
      /** @param {CustomEvent<{ key?: string; title?: string; type?: string }>} event */
      (event) => {
        applyNoteContext(event?.detail);
      }
    );

    textarea.addEventListener("keydown", (event) => {
      if ((event.ctrlKey || event.metaKey) && event.key === "Enter") {
        event.preventDefault();
        saveNote();
      }
    });

    clearButton.addEventListener("click", () => {
      if (editingNoteId) {
        cancelEdit();
        setStatus("Editing canceled. Draft restored.");
        return;
      }
      textarea.value = "";
      updatePreview("");
      updateSaveButtonState("");
      if (storageReady) {
        clearDraft();
      }
      setStatus("Draft cleared.");
    });

    exportButton.addEventListener("click", () => {
      if (!storageReady) {
        setStatus("Nothing to export yet.");
        return;
      }
      const payload = notesPayload ?? loadAllNotes();
      const blob = new Blob([JSON.stringify(payload, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement("a");
      const timestamp = new Date().toISOString().replace(/[:]/g, "-");
      anchor.href = url;
      anchor.download = `improv-toolbox-notes-${timestamp}.json`;
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
      window.setTimeout(() => URL.revokeObjectURL(url), 2000);
      setStatus("Exported notes to a JSON file.");
    });

    refreshFromStorage();

    window.addEventListener("pageshow", () => {
      if (storageReady) {
        notesPayload = null;
        refreshFromStorage();
      }
    });

    window.addEventListener("storage", (event) => {
      if (event.key === STORAGE_NAMESPACE) {
        notesPayload = null;
        refreshFromStorage();
        setStatus("Note updated from another tab.");
      }
    });
  });

  /**
   * @typedef {Object} NoteEntry
   * @property {string} id
   * @property {string} content
   * @property {string} savedAt
   * @property {string} [updatedAt]
   */

  /**
   * @typedef {Object} NoteCollection
   * @property {string} id
   * @property {string} type
   * @property {string} title
   * @property {NoteEntry[]} items
   * @property {string} updatedAt
   */

  /**
   * @typedef {Object} DraftEntry
   * @property {string} content
   * @property {string} updatedAt
   */

  /**
   * @typedef {Object} NotesPayload
   * @property {number} version
   * @property {Record<string, NoteCollection>} notes
   * @property {Record<string, DraftEntry>} drafts
   */

  /**
   * @typedef {Object} NotesPayloadLegacy
   * @property {number} version
   * @property {Record<string, NoteLegacyEntry>} notes
   */

  /**
   * @typedef {Object} NoteLegacyEntry
   * @property {string} id
   * @property {string} type
   * @property {string} title
   * @property {string} content
   * @property {string} updatedAt
   */
</script>
