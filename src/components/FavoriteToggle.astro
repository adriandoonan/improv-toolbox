---
import {
  favoriteKey,
  isStorageReady,
  FAVORITES_EVENT,
} from "../utils/favorites";

interface Props {
  contentType: string;
  contentId?: string;
  slug?: string;
  title?: string;
  description?: string;
}

const { contentType, contentId, slug, title, description } = Astro.props as Props;
const slugValue = contentId ?? slug ?? "";
const resolvedTitle = title ?? "this item";
const resolvedDescription = description ?? "";
const key = contentType && slugValue ? favoriteKey(contentType, slugValue) : "";
const hasKey = Boolean(key);
const storageReady = isStorageReady();
const addLabel = "Save to favorites";
const removeLabel = "Remove from favorites";
const srAddLabel = `Add ${resolvedTitle} to favorites`;
const srRemoveLabel = `Remove ${resolvedTitle} from favorites`;
const statusAdd = `${resolvedTitle} added to favorites.`;
const statusRemove = `${resolvedTitle} removed from favorites.`;
const fallbackMessage = hasKey
  ? storageReady
    ? "Favorites will be ready once the page is fully loaded."
    : "Favorites require local storage support in your browser."
  : "Favorites are unavailable for this entry.";
---

<div
  class="favorite-toggle"
  data-favorite-root
  data-favorite-key={key}
  data-favorite-type={contentType}
  data-favorite-slug={slugValue}
  data-favorite-title={resolvedTitle}
  data-favorite-description={resolvedDescription}
  data-favorite-event={FAVORITES_EVENT}
>
  <button
    type="button"
    class="favorite-toggle__button"
    aria-pressed="false"
    data-favorite-button
    disabled={!hasKey || !storageReady}
  >
    <span aria-hidden="true" data-favorite-visible-text>{addLabel}</span>
    <span class="sr-only" data-favorite-sr-text>{srAddLabel}</span>
  </button>
  <span
    class="favorite-toggle__status sr-only"
    role="status"
    aria-live="polite"
    data-favorite-status
  ></span>
  <span class="favorite-toggle__fallback" data-favorite-fallback>{fallbackMessage}</span>
</div>

<script
  type="module"
  lang="ts"
  define:vars={{
    key,
    slugValue,
    contentType,
    resolvedTitle,
    resolvedDescription,
    addLabel,
    removeLabel,
    srAddLabel,
    srRemoveLabel,
    statusAdd,
    statusRemove,
    fallbackMessage,
  }}
>
  import {
    loadFavorites,
    toggleFavorite,
    subscribeToFavorites,
    isStorageReady,
    FAVORITES_EVENT,
  } from "../utils/favorites";
  import type { FavoriteChangeDetail } from "../utils/favorites";

  const root = document.currentScript?.parentElement;
  if (!root) {
    return;
  }

  root.dataset.favoriteEvent = FAVORITES_EVENT;

  const button = root.querySelector<HTMLButtonElement>("[data-favorite-button]");
  const visibleText = root.querySelector<HTMLElement>("[data-favorite-visible-text]");
  const srText = root.querySelector<HTMLElement>("[data-favorite-sr-text]");
  const statusEl = root.querySelector<HTMLElement>("[data-favorite-status]");
  const fallbackEl = root.querySelector<HTMLElement>("[data-favorite-fallback]");

  const disableControl = (message: string) => {
    if (button) {
      button.disabled = true;
      button.setAttribute("aria-pressed", "false");
    }
    if (visibleText) {
      visibleText.textContent = addLabel;
    }
    if (srText) {
      srText.textContent = srAddLabel;
    }
    if (fallbackEl) {
      fallbackEl.hidden = false;
      fallbackEl.textContent = message;
    }
    if (statusEl) {
      statusEl.textContent = message;
    }
  };

  if (!key || !button) {
    disableControl("Favorites are unavailable for this entry.");
    return;
  }

  if (!isStorageReady()) {
    disableControl("Favorites require local storage support in your browser.");
    return;
  }

  const toggleText = (isFavorite: boolean) => {
    button.setAttribute("aria-pressed", String(isFavorite));
    if (visibleText) {
      visibleText.textContent = isFavorite ? removeLabel : addLabel;
    }
    if (srText) {
      srText.textContent = isFavorite ? srRemoveLabel : srAddLabel;
    }
  };

  const announce = (isFavorite: boolean) => {
    if (!statusEl) return;
    statusEl.textContent = isFavorite ? statusAdd : statusRemove;
  };

  const favoriteDetail = {
    type: contentType,
    slug: slugValue,
    title: resolvedTitle,
    description: resolvedDescription,
  };

  if (fallbackEl) {
    fallbackEl.hidden = true;
  }

  button.disabled = false;

  const payload = loadFavorites();
  toggleText(Boolean(payload.items[key]));

  const clickController = new AbortController();
  const handleClick = () => {
    const detail = toggleFavorite(key, favoriteDetail);
    if (!detail) return;
    const isFavorite = Boolean(detail.isFavorite);
    toggleText(isFavorite);
    announce(isFavorite);
  };

  button.addEventListener("click", handleClick, { signal: clickController.signal });

  const handleChange = (detail: FavoriteChangeDetail) => {
    if (!detail || !detail.payload) return;
    const isFavorite = Boolean(detail.payload.items[key]);
    toggleText(isFavorite);
    if (detail.key === key) {
      announce(isFavorite);
    }
  };

  const unsubscribe = subscribeToFavorites(handleChange);

  let cleaned = false;
  const cleanup = () => {
    if (cleaned) return;
    cleaned = true;
    clickController.abort();
    unsubscribe?.();
    if (fallbackEl) {
      fallbackEl.hidden = false;
      fallbackEl.textContent = fallbackMessage;
    }
  };

  window.addEventListener("astro:before-swap", cleanup, { once: true });

  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      for (const node of mutation.removedNodes) {
        if (node === root || (node instanceof Element && node.contains(root))) {
          observer.disconnect();
          cleanup();
          return;
        }
      }
    }
  });

  if (root.parentElement) {
    observer.observe(root.parentElement, { childList: true, subtree: true });
  } else {
    observer.observe(document.body, { childList: true, subtree: true });
  }
</script>

<style>
  .favorite-toggle {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .favorite-toggle__button {
    border-radius: 999px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    background: color-mix(in srgb, var(--surface-raised, #1f1521) 70%, black 30%);
    color: var(--color-heading, #fff5f7);
    padding: 0.35rem 0.9rem;
    font-size: 0.95rem;
    font-weight: 600;
    letter-spacing: 0.02em;
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
  }

  .favorite-toggle__button:hover,
  .favorite-toggle__button:focus-visible {
    border-color: color-mix(in srgb, var(--color-accent, #ff2f55) 45%, transparent);
    transform: translateY(-1px);
    box-shadow: 0 8px 20px rgba(15, 6, 18, 0.35);
  }

  .favorite-toggle__button[aria-pressed="true"] {
    border-color: color-mix(in srgb, var(--color-accent, #ff2f55) 65%, transparent);
    background: color-mix(in srgb, var(--color-accent, #ff2f55) 35%, transparent);
  }

  .favorite-toggle__button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  .favorite-toggle__fallback {
    font-size: 0.85rem;
    color: color-mix(in srgb, var(--color-muted, #cbbfca) 80%, black 20%);
  }
</style>
