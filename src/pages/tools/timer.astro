---
import BaseLayout from "../../layouts/BaseLayout.astro";
export const tool = {
  name: "Timer",
  description: "Simple countdown timer for improv.",
  icon: "⏱",
  creator: "Adrian Doonan",
  href: "/tools/timer",
};
---

<BaseLayout title="Timer Tool" description="Simple countdown timer for improv.">
  <section class="center" style="max-width:28rem;margin-top:2rem;">
    <h1 class="mar-0">Timer</h1>
    <p class="mute">Set a time, start, and go!</p>
    <div id="timerPanelHost" style="position:relative;">
      <div id="timerPanel" class="card" style="padding:2rem;position:relative;">
        <label for="timerInput" class="fullscreen-hide">Seconds:</label>
        <input
          id="timerInput"
          type="number"
          min="1"
          value="60"
          class="fullscreen-hide"
          style="width:6em;text-align:center;font-size:1.2em;"
        />
        <button
          id="startBtn"
          class="contrast fullscreen-hide"
          style="margin-left:1em;"
          >Start</button
        >
        <button
          id="resetBtn"
          class="secondary fullscreen-hide"
          style="margin-left:1em;"
          >Reset</button
        >
        <button
          id="fullscreenBtn"
          class="secondary fullscreen-hide"
          style="margin-left:1em;"
        >
          Full screen
        </button>
        <button
          id="exitFullscreenBtn"
          class="secondary fullscreen-only"
          style="display:none;"
        >
          Exit full screen
        </button>
        <h2
          id="timerDisplay"
          class="num"
          style="font-size:3em;margin:1.5em 0 0 0;"
        >
          01:00
        </h2>
        <small id="timerStatus" class="mute fullscreen-hide">Ready.</small>
        <div
          class="suggestion-area"
          style="margin-top:2rem;display:flex;flex-direction:column;gap:0.5rem;align-items:center;"
        >
          <button id="suggestionBtn" class="secondary fullscreen-hide">
            Get suggestion
          </button>
          <p
            id="suggestionOutput"
            class="mute"
            data-has-suggestion="false"
            style="min-height:1.5em;margin:0;"
          >
            Need a prompt? Grab a word.
          </p>
        </div>
      </div>
    </div>
    <dialog id="timerFullscreenDialog" class="timer-fullscreen-dialog">
      <div id="timerDialogMount" class="timer-dialog-mount"></div>
    </dialog>
  </section>
  <script>
    let duration = 60;
    let remaining = 60;
    let running = false;
    let paused = false;
    let countingUp = false;
    let tickHandle = null;
    let flashHandle = null;
    let wakeLock = null;
    const input = document.getElementById(
      "timerInput"
    ) as HTMLInputElement | null;
    const display = document.getElementById("timerDisplay");
    const startBtn = document.getElementById("startBtn");
    const resetBtn = document.getElementById("resetBtn");
    const status = document.getElementById("timerStatus");
    const suggestionBtn = document.getElementById("suggestionBtn");
    const suggestionOutput = document.getElementById("suggestionOutput");
    const fullscreenBtn = document.getElementById("fullscreenBtn");
    const exitFullscreenBtn = document.getElementById("exitFullscreenBtn");
    const timerPanel = document.getElementById("timerPanel") as HTMLElement | null;
    const timerPanelHost = document.getElementById(
      "timerPanelHost"
    ) as HTMLElement | null;
    const fullscreenDialog = document.getElementById(
      "timerFullscreenDialog"
    ) as HTMLDialogElement | null;
    const dialogMount = document.getElementById(
      "timerDialogMount"
    ) as HTMLElement | null;
    const docAny = document as any;
    const requestFullscreenFn = timerPanel
      ? (timerPanel as any).requestFullscreen ||
        (timerPanel as any).webkitRequestFullscreen ||
        (timerPanel as any).mozRequestFullScreen ||
        (timerPanel as any).msRequestFullscreen
      : null;
    const fullscreenEnabledFlag = (() => {
      if (typeof document.fullscreenEnabled === "boolean") {
        return document.fullscreenEnabled;
      }
      if (typeof docAny.webkitFullscreenEnabled === "boolean") {
        return docAny.webkitFullscreenEnabled;
      }
      if (typeof docAny.mozFullScreenEnabled === "boolean") {
        return docAny.mozFullScreenEnabled;
      }
      if (typeof docAny.msFullscreenEnabled === "boolean") {
        return docAny.msFullscreenEnabled;
      }
      return true;
    })();
    const supportsNativeFullscreen = Boolean(
      requestFullscreenFn && fullscreenEnabledFlag
    );
    let usingDialogFullscreen = false;
    const fallbackWords = [
      "spark",
      "stride",
      "whirl",
      "pivot",
      "echo",
      "glimmer",
      "pulse",
      "riff",
    ];
    if (suggestionOutput) {
      suggestionOutput.dataset.hasSuggestion =
        suggestionOutput.dataset.hasSuggestion || "false";
    }
    function fmt(sec) {
      const m = String(Math.floor(sec / 60)).padStart(2, "0");
      const s = String(Math.abs(sec % 60)).padStart(2, "0");
      return m + ":" + s;
    }
    function render() {
      if (display) display.textContent = fmt(remaining);
      if (fullscreenActive()) {
        applyFullscreenBaseStyles();
      } else {
        if (!countingUp) {
          if (display) display.style.color = "";
          document.body.style.background = "";
        } else {
          if (display) display.style.color = "#c00";
        }
      }
    }
    function setStartLabel(text) {
      if (startBtn) startBtn.textContent = text;
    }
    function beginTick() {
      running = true;
      paused = false;
      setStartLabel("Pause");
      if (status)
        status.textContent = countingUp ? "Time's up!" : "Running…";
      tickHandle = window.setInterval(() => {
        if (!countingUp) {
          remaining--;
          render();
          if (remaining <= 0) {
            countingUp = true;
            remaining = 0;
            if (status) status.textContent = "Time's up!";
            if (display)
              display.style.color = fullscreenActive() ? "#ff5252" : "#c00";
            flashBackground();
          }
        } else {
          remaining++;
          render();
        }
      }, 1000);
      requestWakeLock();
    }
    function startTimer() {
      if (running) return;
      countingUp = false;
      duration = Math.max(1, input ? Number(input.value) || 1 : 1);
      remaining = duration;
      if (flashHandle !== null) {
        stopFlashing();
      }
      render();
      beginTick();
    }
    function resumeTimer() {
      if (running || !paused) return;
      beginTick();
    }
    function pauseTimer() {
      if (!running) return;
      running = false;
      paused = true;
      if (tickHandle !== null) clearInterval(tickHandle);
      tickHandle = null;
      setStartLabel("Start");
      if (status)
        status.textContent = countingUp ? "Paused (overtime)." : "Paused.";
      releaseWakeLock();
    }
    function resetTimer() {
      running = false;
      countingUp = false;
      paused = false;
      if (tickHandle !== null) clearInterval(tickHandle);
      tickHandle = null;
      stopFlashing();
      remaining = Math.max(1, input ? Number(input.value) || 1 : 1);
      render();
      if (status) status.textContent = "Ready.";
      if (!fullscreenActive()) document.body.style.background = "";
      releaseWakeLock();
      setStartLabel("Start");
    }
    function flashBackground() {
      let on = false;
      flashHandle = window.setInterval(() => {
        if (fullscreenActive()) {
          if (timerPanel && display) {
            if (on) {
              timerPanel.style.background = "#000";
              display.style.color = "#ff5252";
            } else {
              timerPanel.style.background = "#ff5252";
              display.style.color = "#000";
            }
          }
        } else {
          document.body.style.background = on ? "#fff3f3" : "#ffe3e3";
        }
        on = !on;
      }, 400);
    }
    function requestWakeLock() {
      if ("wakeLock" in navigator && running) {
        navigator.wakeLock
          .request("screen")
          .then((lock) => {
            wakeLock = lock;
            if (wakeLock)
              wakeLock.addEventListener("release", () => {
                wakeLock = null;
              });
          })
          .catch(() => {});
      }
    }
    function releaseWakeLock() {
      if (wakeLock && typeof wakeLock.release === "function") {
        wakeLock.release();
        wakeLock = null;
      }
    }
    function fullscreenActive() {
      return (
        usingDialogFullscreen || document.fullscreenElement === timerPanel
      );
    }
    function applyFullscreenBaseStyles() {
      if (!timerPanel || !display) return;
      if (flashHandle === null) {
        timerPanel.style.background = "#000";
        display.style.color = "#ff5252";
      }
      display.style.fontFamily = "'Share Tech Mono', 'Courier New', monospace";
    }
    function clearFlashEffects() {
      if (timerPanel) timerPanel.style.background = fullscreenActive() ? "#000" : "";
      if (display) {
        display.style.color = fullscreenActive() ? "#ff5252" : "";
        if (!fullscreenActive()) display.style.fontFamily = "";
      }
      if (!fullscreenActive()) document.body.style.background = "";
    }
    function stopFlashing() {
      if (flashHandle !== null) {
        clearInterval(flashHandle);
        flashHandle = null;
      }
      clearFlashEffects();
    }
    function stopTimerAndCleanup({
      exitFullscreen: shouldExitFullscreen = false,
      statusText,
    }: { exitFullscreen?: boolean; statusText?: string } = {}) {
      const wasCountingUp = countingUp;
      if (tickHandle !== null) {
        clearInterval(tickHandle);
        tickHandle = null;
      }
      stopFlashing();
      running = false;
      paused = false;
      countingUp = false;
      if (wasCountingUp) {
        remaining = 0;
      }
      releaseWakeLock();
      setStartLabel("Start");
      if (status)
        status.textContent =
          typeof statusText === "string"
            ? statusText
            : wasCountingUp
            ? "Time's up!"
            : "Stopped.";
      render();
      if (shouldExitFullscreen && fullscreenActive()) {
        exitFullscreen();
      } else if (!fullscreenActive()) {
        clearFlashEffects();
      }
    }
    function toggleTimer() {
      if (running) {
        pauseTimer();
      } else if (paused) {
        resumeTimer();
      } else {
        startTimer();
      }
    }
    if (startBtn) startBtn.addEventListener("click", toggleTimer);
    if (resetBtn) resetBtn.addEventListener("click", resetTimer);
    function handleFullscreenTap(options: { fromDisplay?: boolean } = {}) {
      const { fromDisplay = false } = options;
      if (!fullscreenActive()) return;
      const isFlashing = flashHandle !== null && countingUp;
      if (isFlashing) {
        stopTimerAndCleanup({ exitFullscreen: true, statusText: "Time's up!" });
        return;
      }
      if (fromDisplay) {
        toggleTimer();
      }
    }
    if (display)
      display.addEventListener("click", (event) => {
        event.stopPropagation();
        handleFullscreenTap({ fromDisplay: true });
      });
    function openDialogFullscreen() {
      if (!fullscreenDialog || !dialogMount || !timerPanel) return;
      usingDialogFullscreen = true;
      if (timerPanel.parentElement !== dialogMount) {
        dialogMount.appendChild(timerPanel);
      }
      if (!fullscreenDialog.open) {
        try {
          fullscreenDialog.showModal();
        } catch (err) {
          usingDialogFullscreen = false;
          if (timerPanelHost && timerPanel.parentElement !== timerPanelHost) {
            timerPanelHost.appendChild(timerPanel);
          }
          if (status) status.textContent = "Fullscreen not available.";
          return;
        }
      }
      updateFullscreenUI();
      render();
    }
    function closeDialogFullscreen() {
      if (!timerPanel || !timerPanelHost) return;
      if (fullscreenDialog?.open) {
        fullscreenDialog.close();
      }
      if (timerPanel.parentElement !== timerPanelHost) {
        timerPanelHost.appendChild(timerPanel);
      }
      usingDialogFullscreen = false;
      clearFlashEffects();
      updateFullscreenUI();
      render();
    }
    async function enterFullscreen() {
      if (!timerPanel) return;
      if (supportsNativeFullscreen) {
        try {
          const result = requestFullscreenFn?.call(timerPanel);
          if (result && typeof (result as Promise<void>).then === "function") {
            await result;
          }
          return;
        } catch (err) {
          if (status) status.textContent = "Using fallback full screen.";
        }
      }
      openDialogFullscreen();
    }
    function exitFullscreen() {
      if (usingDialogFullscreen) {
        closeDialogFullscreen();
      } else if (document.fullscreenElement) {
        document.exitFullscreen().catch(() => {});
      }
    }
    function updateFullscreenUI() {
      const active = fullscreenActive();
      timerPanel?.classList.toggle("fullscreen-active", active);
      display?.classList.toggle("fullscreen-display", active);
      if (fullscreenBtn) fullscreenBtn.style.display = active ? "none" : "";
      if (exitFullscreenBtn)
        exitFullscreenBtn.style.display = active ? "" : "none";
      if (active) {
        applyFullscreenBaseStyles();
      } else {
        clearFlashEffects();
      }
    }
    if (fullscreenBtn)
      fullscreenBtn.addEventListener("click", () => {
        enterFullscreen();
      });
    if (fullscreenDialog)
      fullscreenDialog.addEventListener("cancel", (event) => {
        event.preventDefault();
        if (usingDialogFullscreen) {
          closeDialogFullscreen();
        }
      });
    if (timerPanel)
      timerPanel.addEventListener("click", (event) => {
        if (!fullscreenActive()) return;
        const target = event.target as HTMLElement | null;
        if (target?.closest(".fullscreen-only")) return;
        if (target === display) return;
        const isFlashing = flashHandle !== null && countingUp;
        if (isFlashing) {
          stopTimerAndCleanup({ exitFullscreen: true, statusText: "Time's up!" });
        }
      });
    if (exitFullscreenBtn)
      exitFullscreenBtn.addEventListener("click", (event) => {
        event.stopPropagation();
        const isFlashing = flashHandle !== null && countingUp;
        if (isFlashing) {
          stopTimerAndCleanup({ exitFullscreen: true, statusText: "Time's up!" });
        } else if (fullscreenActive()) {
          exitFullscreen();
        }
      });
    document.addEventListener("fullscreenchange", () => {
      updateFullscreenUI();
      render();
    });
    async function fetchSuggestion() {
      if (!suggestionBtn || !suggestionOutput) return;
      const originalLabel = suggestionBtn.textContent || "Get suggestion";
      suggestionBtn.disabled = true;
      suggestionBtn.textContent = "Loading…";
      suggestionOutput.textContent = "";
      suggestionOutput.dataset.hasSuggestion = "false";
      try {
        const response = await fetch(
          "https://random-word-api.herokuapp.com/word?lang=en&number=1",
          {
            cache: "no-store",
          }
        );
        if (!response.ok) throw new Error("Bad response");
        const data = await response.json();
        const word = Array.isArray(data) ? data[0] : "";
        if (word) {
          suggestionOutput.textContent = String(word);
          suggestionOutput.classList.remove("mute");
          suggestionOutput.dataset.hasSuggestion = "true";
        } else {
          suggestionOutput.textContent = "No suggestion right now.";
          suggestionOutput.classList.add("mute");
          suggestionOutput.dataset.hasSuggestion = "false";
        }
      } catch (err) {
        const fallback =
          fallbackWords[Math.floor(Math.random() * fallbackWords.length)] ||
          "idea";
        suggestionOutput.textContent = fallback;
        suggestionOutput.classList.remove("mute");
        suggestionOutput.dataset.hasSuggestion = "true";
      } finally {
        suggestionBtn.disabled = false;
        suggestionBtn.textContent = originalLabel;
      }
    }
    if (suggestionBtn) suggestionBtn.addEventListener("click", fetchSuggestion);
    if (input)
      input.addEventListener("input", () => {
        if (!running && !paused) {
          remaining = Math.max(1, Number(input.value) || 1);
          render();
        }
      });
    setStartLabel("Start");
    render();
  </script>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap");
    .fullscreen-active {
      width: 100vw;
      height: 100vh;
      max-width: none !important;
      max-height: none;
      margin: 0;
      border-radius: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: clamp(1.5rem, 5vh, 3.5rem);
      padding: clamp(3rem, 6vh, 5rem) clamp(3rem, 6vw, 5rem) !important;
      background: #000;
      box-shadow: none;
      border: none;
    }
    .fullscreen-active::before {
      display: none;
    }
    .fullscreen-active .fullscreen-hide {
      display: none !important;
    }
    .fullscreen-active .fullscreen-only {
      position: absolute;
      top: 3rem;
      right: 3rem;
      background: #111827;
      border-color: #ff525280;
      color: #ffbaba;
      box-shadow: 0 12px 24px #00000055;
    }
    .fullscreen-active .fullscreen-only:hover,
    .fullscreen-active .fullscreen-only:focus {
      background: #1f2937;
      border-color: #ff7676;
      color: #fff;
    }
    .fullscreen-display {
      flex: 1 1 auto;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: min(calc((100vw - 6rem) / 4), calc((100vh - 6rem) * 0.55));
      letter-spacing: 0.08em;
      margin: 0 !important;
      cursor: pointer;
      line-height: 1;
      text-shadow: 0 0 20px #ff3b3b66, 0 0 40px #ff000044;
    }
    .fullscreen-active .suggestion-area {
      margin-top: auto;
      width: 100%;
      align-items: center !important;
    }
    .fullscreen-active #suggestionOutput {
      font-size: clamp(1.5rem, 4vw, 2.8rem);
      color: #ff9d9d;
      letter-spacing: 0.05em;
      text-align: center;
    }
    .fullscreen-active #suggestionOutput[data-has-suggestion="false"] {
      display: none;
    }
    .timer-fullscreen-dialog {
      padding: 0;
      border: none;
      background: transparent;
      width: 100vw;
      height: 100vh;
      max-width: none;
      max-height: none;
    }
    .timer-fullscreen-dialog::backdrop {
      background: #000;
    }
    .timer-dialog-mount {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }
    #timerPanelHost:empty {
      min-height: 0;
    }
  </style>
</BaseLayout>
